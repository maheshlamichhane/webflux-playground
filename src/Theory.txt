Summary
-> Reactive vs Traditional API
-> Responsive
    * reacting quickly
    * streaming response
    * cancel

Spring Data R2DBC(Reactive Relational Database Connectivity)
-> JPA is a specification for traditional synchronous programming.
-> R2DBC is a separate specification for reactive programming
-> R2DBC != JPA

R2DBC
-> Prioritized
    * Performance
    * Scalability
    * Streaming + Backpressure(I will demo with Postgres driver)
-> It does not have features like
    * @OneToMany
    * @ManyToMany


R2DBC Drivers/Config
h1 -> r2dbc:h2:mem:///userdb
postgres -> r2dbc:postgresql://localhost:5432/userdb
mysql -> r2dbc:mysql://localhost:3306/userdb


StepVerifier:
-> StepVerifier.create()
-> Next
    * expectNext(...)
    * expectNextCount()
    * thenConsumeWhile()
    * assertNext()
-> Complete/Error
    * expectComplete()
    * expectError()
-> verify
    * verify

Mutating Objects
-> Reactive programming is functional style programming for IO
-> Function programming prefers pure functions(with no side effects)!
    * Perfer pure funcitons where it is possible but not blindly everywhere
-> your table is mutuable! your entity object is mutable.
    * it is OK to mutate.


Pageable:
-> To request for chunks of data from larger data set
    * Page 1, Size 10
    * Sort by Price ascending

Complex Queries / Join
-> Prefer SQL
    * it is efficient
    * No N+1 problem

Repository / Database Client
-> Repository(@Query)
-> Database client


Projection:



Spring Data JPA VS Spring Data R2DBC:
->


Reactive Principle:
i. Responsive -> The ability of the system to react / respond quickly.
ii. Resilent -> The ability of the system to stay responsive even in case of failures.
iii. Elastic -> The ability of the system to stay responsive even under varying workload/
system resources.
iv. Message Driven -> The ability of the systems to communicate using messages in a non-blocking
manner by applying back pressure if necessary.


Body Vs BodyValue
bodyValue -> Actual raw object not publisher type
body -> publisher type Mono<CustomerDto> mono
body(mono,CustomerDto.class)


Input Validation and Error handling:->


WebFilter:
-> webfilter -> controller -> service

Functional Endpoints:




























